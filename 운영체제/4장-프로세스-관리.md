## [프로세스 관리 #1](https://core.ewha.ac.kr/publicview/C0101020140321144554159683?vmode=f)

**프로세스 생성:**

부모가 자식을 생성

주소 공간 

- 자식은 부모의 공간을 그대로 복사를 합니다.
- 자식은 그 공간에 새로운 프로그램을 올립니다.



**프로세스의 종료**

프로세스가 마지막 명령을 수행한 후 운영체제에게 이를 알려줌(exit)

- 자식이 부모에게 output data를 보냄(via wait) 자식이 항상먼저죽음
- 프로세스의 각종 자원들이 운영체제에게 반납됨

부모 프로세스가 자식의 수행을 강제로 종료시킴(abort)

- 자식이 할당 자원의 한계치를 넘어섬
- 자식이 할당 된 태스크가 더 이상 필요하지 않음
- 부모가 종료하는 경우
  - 운영체제는 부모 프로세스가 종료하는 경우 자식이 더이상 수행되도록 두지 않는다.

## [프로세스 관리 #2](https://core.ewha.ac.kr/publicview/C0101020140325134428879622?vmode=f)



**fork()시스템콜**(새로운 프로세스 생성)

부모는  fork()함수의 결과값으로 양수가 얻어지고 자식의 경우 음수가 얻습니다.

이 결과 값으로 다른 일을 실행 시킬 수 있습니다.

**exec() 시스템콜(완전히 새로운 프로세스로 덮여쓰여지는 느낌)**

간단히 말해 fork()와 exec()의 차이점은

fork()의 결과는 프로세스가 하나 더 생기는것입니다.(프로세스 id가 완전히 다른 또 하나의 프로세스가생기는것입니다.)

exec()실행의 결과로 생성되는 새로운 프로세스는 없고, exec()를 호출한 프로세스의 PID가 그대로 새로운 프로세스에 적용이 되며, exec()를 호출한 프로세스는 새로운 프로세스에 의해 덮어 쓰여지게 됩니다.



**wait()시스템콜(잠들게 하는 느낌)**

프로세스 A가 wait() 시스템 콜을 호출하면

- 커널은 child가 종료될 때까지 프로세스 A를 sleep시킨다(block상태)
- 자식 프로세스가 종료되면 커널은 프로세스A를 깨운다(ready상태)



***exit()시스템콜(프로세스종료)***

자발적 종료

- 마지막 statement 수행 후 exit() 시스템 콜을 통해

비자발적 종료

- 부모 프로세스가 자식 프로세스를 강제 종료시킴
  - 자식 프로세스가 한계치를 넘어서는 자원 요청
  - 자식이 더이상 할일이 없음
- 키보드로 kill,break등을 친 경우
- 부모가 종료하는 경우



프로세스 간 협력

프로세스 간 협력 매커니즘(IPC:Interprocess Communication)

- 메세지들 전달하는 방법

  - message-passing: 커널을 통해 메세지 전달

  ![img](https://blog.kakaocdn.net/dn/bvK4Wj/btrd0Xcc84v/dINeMKFy19enezry5RHkEk/img.png)

-  주소 공간을 공유하는 방법

  - shared memory :서로 다른 프로세스 간에도 일부 주소 공간을 공유하게 하는 shared memory  매커니즘이 있음



CPU스케줄링

프로세스는 그 특성에 따라 다음 두 가지로 나눔

- I/O-bound process
  - cpu를 잡고 계산하는 시간보다 i/o에 많은 시간이 필요한 job
- CPU-bound process
  - 계산 위주

CPU Scheduler (운영체제에서 해주는 기능)

- 프로세스 중에서 이번에 CPU를 줄 프로세스를 고르는 것

Dispatcher

- CPU의 제어권을 CPU scheduler에 의해 선택된 프로세스에게 넘긴다
- 이 과정을 context switch(문맥교환) 라고한다

