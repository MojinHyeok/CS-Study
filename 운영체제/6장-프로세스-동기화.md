## [프로세스 동기화 #1](https://core.ewha.ac.kr/publicview/C0101020140401134252676046?vmode=f)
## 데이터의 접근



![img](https://blog.kakaocdn.net/dn/csmAxG/btreLJ5b8zi/FL5cctVMPRRAFKpcCRAje0/img.png)



- 데이터를 읽어와서 연산된 데이터를 다시 위치한 데이터에 저장
- (1) CPU(연산) Memory(스토리지)
- (2) 컴퓨터 내부(연산) 디스크(스토리지)
- (3) 프로세스(연산) 프로세스의 주소 공간(스토리지)

## Race Condition



![img](https://blog.kakaocdn.net/dn/CQeKl/btreKkSzgyx/JRQr5oV0YErD4suaURCfPK/img.png)



- 공통적인 데이터를 동시에 사용하려는 경우 한 가지의 연산만 처리될 때 경쟁상태라고 말합니다.

### OS에서의 Race Condition

- 운영체제에서의 커널과 관련된 문제
- 프로세스는 일반적으로는 자기 주소 공간만 접근하기 때문에 Race Condition은 발생하지 않는다.
- 프로세스들이 직접 실행할 수 없는 부분 운영체제에 요청하는 부분은 시스템 콜을 통해 실행합니다.
- 커널의 코드가 그 프로세스 대신 실행(커널의 데이터를 접근), 이러한 상황에서 CPU를 뺏겨서 또 다른 프로세스가 시스템 콜을 한다면 Race Condition 발생하게 된다.
- 운영체제의 커널 데이터가 공유 데이터라 문제가 발생합니다.

## 대표적 OS Race Condition

1.Kernel 수행 중 인터럽트 발생 시



![img](https://blog.kakaocdn.net/dn/me7vu/btreRTFGw5c/6enbDi8IZ2pCGVQCTOGDrK/img.png)



해결책은 위의 사진의 경우 Count++를 먼저 실행 후 작업이 끝난 이후 인터럽트를 실행시켜줍니다.

2. Process가 system call을 하여 kernel mode로 수행 중인데 context switch가 일어나는 경우



![img](https://blog.kakaocdn.net/dn/oz2XL/btreLgB8Vq2/pk0op6q2ExXrP5YhlUA1fK/img.png)



해결책: 커널 모드에서 수행 중일 때는 CPU를 선점하지 않고 커널 모드에서 사용자 모드로 선점합니다.

3. Multiprocessor에서 shared memory내의 kernel data



![img](https://blog.kakaocdn.net/dn/H21rD/btreOtHvWri/vdmyuffC3eVquu1B3c3ej0/img.png)



해결책은: 커널 내부에 있는 공유 데이터에 대한 lock / unlock을 하여 관리

 한 번에 하나의 CPU만 커널에 들어가게 하는 방법

### Process Synchronization

문제공유 데이터의 동시 접근은 데이터의 불일치 문제를 발생시킬 수 있습니다.

일관성 유지를 위해서는 협력 프로세스 간의 실행 순서를 정리해주는 메커니즘이 필요.

### The Critical-Section Problem(임계 구역)



![img](https://blog.kakaocdn.net/dn/xZBBl/btreKlqsPp0/LnMGkA6Jl1GBw5KaFwLSpk/img.png)

n개의 프로세스가 공유 데이터를 동시에 사용하기를 원하는 경우

각 프로세스의  code segment에는 공유 데이터를 접근하는 코드인 critical section이 존재합니다.

공유 데이터에 접근하는 코드를 Critical-Section입니다.

Problem: 하나의 프로세스가 Critical-Section에 있을 때 다른 모든 프로세스는 critical section에 들어갈 수 없어야 한다.(사용 중이면 기다려야 한다)


# 프로그램적 해결법의 충족 조건

![img](https://blog.kakaocdn.net/dn/V6YC8/btrfw4Vp5p7/HAn0ztNyGn4p6oZZCE0T60/img.png)

상호배제:lock unlock

Progress : 코드를 잘 못 짜면 이러한 문제가 발생

유한대기: 기다리는 시간이 유한해야한다(starvation이 생기면 안됨)

ex) 프로세스가 3개가 있는데 2개만 계속 사용하고 한개는 계속 기다리는 상황일 때





# Algorithm1

![img](https://blog.kakaocdn.net/dn/uldSr/btrfFFNQmtN/7J0OCaIPEpXSyYmkIn0xG0/img.png)

turn 은 누구의 차례를 나타냄

while 문을 돌면서 자기의 차례를 계속 기다림 -> 그다음 크리티컬 섹션->그다음 상대방의 턴으로 바꿈

1.상호배제를 만족함

2.Progress를 만족하지못함 (상대방이 들어가야 자기가 들어갈 수 있음)



# Algorithm2

![img](https://blog.kakaocdn.net/dn/C98bO/btrfs5tbv8r/FL66DE2tIq2hwAA1SWlgv1/img.png)

flag 자기가 들어가고 싶은지 의사표시

while문을 통해 상대방이 들어가고 싶은지 확인.

상호배제와 Progress는 만족하지만 둘다(flag가 true이면 둘다 기다리는 상황)



# Algorithm3(Peterson's Algorithm)

![img](https://blog.kakaocdn.net/dn/HLgYb/btrfG3noaJl/wpr6CZPfaKnZ274lsAxVH0/img.png)

turn과 flag를 동시에 사용

하지만 문제점이 존재한다.

Busy Waiting

P0한테 cpu 할당 시간이 왔을 때 , while 문에서 빠져나가지 못할 경우도 있다. 결국자신의 cpu할당 시간에 게속 체크만 하다 끝나는 경우



# Synchronization Hardware

![img](https://blog.kakaocdn.net/dn/98OJu/btrfG2INCVG/J6tbKt0kTvCQkltfuo11rk/img.png)

읽는 작업과 수정작업을 하나의 작업으로 처리해주는 것.

## [프로세스 동기화 #2](https://core.ewha.ac.kr/publicview/C0101020140404151340260748?vmode=f)



# Semaphores


- 공유된 자원의 데이터 혹은 임계영역(Critical Section) 등에 여러 Process 혹은 Thread가 접근하는 것을 막아줌(즉, 동기화 대상이 하나 이상)
- Integer variable(변숫값이 자원의 개수)
- 아래의 두 가지 atomic 연산에 의해서 접근 가능



![img](https://blog.kakaocdn.net/dn/7X5Ta/btreOttYaqU/xaXJg4ufDwMRNFEgNKwvGK/img.png)



P->공유 데이터를 획득하는 과정

V->공유 데이터를 다 사용하고 반납하는 과정.

## Critical Section of n Processes



![img](https://blog.kakaocdn.net/dn/LWsmL/btreJRC65Yn/uHKKcQFjsODO192kXkjAl0/img.png)



- 추상 자료 형태로 제공해주고 세마포어로 정의

## Block / Wakeup Implementation



![img](https://blog.kakaocdn.net/dn/ld6zh/btreLLaQdj3/KAWNC6HSTWKVtbIdxZzp31/img.png)



1. 세마포어를 획득할 수없다면 block를 시키고

2. 누군가가 세마포어를 쓰고 반납을 하면 깨워서 사용한다.



![img](https://blog.kakaocdn.net/dn/bbfgO8/btreJQKZWng/hG8SZDtuVfmri9qoS9gx21/img.png)



여기서 S.value는 상황을 나타냅니다.

음수-> 누군가가 자원을 기다리고 있다.

양수-> 자원이 여분이 있기 때문에 기다리지 않고 쓰고 있다.

# Two Types of Semaphores

- Counting semaphore
  - 도메인이 0 이상인 임의의 정수 값
- Binary semaphore(boolean?)
  - 0 또는 1 값만 가질 수 있는 semaphore
  - 주로 lock/unlock에 사용

# Deadlock and Starvation

Deadlock:둘 이상의 프로세스가 서로 상대방의 의해 충족될 수 있는 event를 무한히 기다리는 현상



![img](https://blog.kakaocdn.net/dn/M9E4N/btreKKwM3Gk/ly6yearYmmDcOFHfc0NuqK/img.png)



P0은 P(S)를 가지고 P1은 P(Q)를 가진 이후 P0은 P(Q)를 가져야 하고 P1은 P(S)를 가져야 하는데 서로 자원을 가진 이후 놓지 않고 계속 기다리는 상황.(상대방이 가진 것을 놓지 않고 서로 영원히 기다리는 상황)

Starvation: 특정프로세스만 자원을 받고, 나머지 프로세스는 무한히 기다리는 것.

## [프로세스 동기화 #3](https://core.ewha.ac.kr/publicview/C0101020140408134626290222?vmode=f)

## [프로세스 동기화 #4](https://core.ewha.ac.kr/publicview/C0101020140411143154161543?vmode=f)

# Reader-Writers Problem

- 한 프로세스가 DB에 write 중일 때 다른 process가 접근하면 안됨.
- 누군가는 쓸때는 lock을 걸지만 read는 lock을 안걸고 동시에 여럿이 읽어도 된다.
- shareddata ->DB 자체

![img](https://blog.kakaocdn.net/dn/yKTmh/btrfuQiMd1v/VEsUIpC7W0b4UDAAJRj6lK/img.png)

읽을 때도 쓰는걸 방지하기 위해 락을 걸지만 읽는 것은 허용해야합니다.

그래서 readcount에 대한 락을 걸고 실행합니다.그리고 마지막으로 읽는 사람이라면 이제 쓰기를 허락하기 위해 읽는 것에 대한 락을 풀어줍니다.

writer가 계속 기다리는 현상이 발생 가능성이 있습니다.



# Dining-Philosophers Problem(식사하는 철학자)

![img](https://blog.kakaocdn.net/dn/xx1Hn/btrfxPcg8eL/PXY3aqrEcArNiGHxngm71K/img.png)

철학자들이 밥을 먹거나 생각을 하거나 둘중의 하나입니다.

여기서 공유자원은 젓가락이 공유자원 입니다.

왼쪽 젓가락과 오른쪽 젓가락을 잡으면 밥을 먹고 다먹으면 왼쪽 젓가락과 오른쪽 젓가락을 놓고 밥을 먹습니다.



하지만 이코드는 

- Deadlock 가능성이 있다. (동시에 배가 고파 왼쪽 젓가락을 들고 있을때 계속 다 기다리기만할 수도 있다.)
- 모든 철학자가 동시게 배가 고파져 왼쪽 젓가락을 집어버린 경우

해결방안

- 4명의 철학자만이 테이블에 동시에 앉도록 한다
- 젓가락을 두 개 모두 집을 수 있을 때에만 젓가락을 집을 수 있게 한다.
- 비대칭 
  - 짝수(홀수) 철학자는 왼쪽(오른쪽) 젓가락부터 집도록




