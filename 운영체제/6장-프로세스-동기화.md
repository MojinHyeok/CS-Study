## [프로세스 동기화 #1](https://core.ewha.ac.kr/publicview/C0101020140401134252676046?vmode=f)
## 데이터의 접근



![img](https://blog.kakaocdn.net/dn/csmAxG/btreLJ5b8zi/FL5cctVMPRRAFKpcCRAje0/img.png)



- 데이터를 읽어와서 연산된 데이터를 다시 위치한 데이터에 저장
- (1) CPU(연산) Memory(스토리지)
- (2) 컴퓨터 내부(연산) 디스크(스토리지)
- (3) 프로세스(연산) 프로세스의 주소 공간(스토리지)

## Race Condition



![img](https://blog.kakaocdn.net/dn/CQeKl/btreKkSzgyx/JRQr5oV0YErD4suaURCfPK/img.png)



- 공통적인 데이터를 동시에 사용하려는 경우 한 가지의 연산만 처리될 때 경쟁상태라고 말합니다.

### OS에서의 Race Condition

- 운영체제에서의 커널과 관련된 문제
- 프로세스는 일반적으로는 자기 주소 공간만 접근하기 때문에 Race Condition은 발생하지 않는다.
- 프로세스들이 직접 실행할 수 없는 부분 운영체제에 요청하는 부분은 시스템 콜을 통해 실행합니다.
- 커널의 코드가 그 프로세스 대신 실행(커널의 데이터를 접근), 이러한 상황에서 CPU를 뺏겨서 또 다른 프로세스가 시스템 콜을 한다면 Race Condition 발생하게 된다.
- 운영체제의 커널 데이터가 공유 데이터라 문제가 발생합니다.

## 대표적 OS Race Condition

1.Kernel 수행 중 인터럽트 발생 시



![img](https://blog.kakaocdn.net/dn/me7vu/btreRTFGw5c/6enbDi8IZ2pCGVQCTOGDrK/img.png)



해결책은 위의 사진의 경우 Count++를 먼저 실행 후 작업이 끝난 이후 인터럽트를 실행시켜줍니다.

2. Process가 system call을 하여 kernel mode로 수행 중인데 context switch가 일어나는 경우



![img](https://blog.kakaocdn.net/dn/oz2XL/btreLgB8Vq2/pk0op6q2ExXrP5YhlUA1fK/img.png)



해결책: 커널 모드에서 수행 중일 때는 CPU를 선점하지 않고 커널 모드에서 사용자 모드로 선점합니다.

3. Multiprocessor에서 shared memory내의 kernel data



![img](https://blog.kakaocdn.net/dn/H21rD/btreOtHvWri/vdmyuffC3eVquu1B3c3ej0/img.png)



해결책은: 커널 내부에 있는 공유 데이터에 대한 lock / unlock을 하여 관리

 한 번에 하나의 CPU만 커널에 들어가게 하는 방법

### Process Synchronization

문제공유 데이터의 동시 접근은 데이터의 불일치 문제를 발생시킬 수 있습니다.

일관성 유지를 위해서는 협력 프로세스 간의 실행 순서를 정리해주는 메커니즘이 필요.

### The Critical-Section Problem(임계 구역)



![img](https://blog.kakaocdn.net/dn/xZBBl/btreKlqsPp0/LnMGkA6Jl1GBw5KaFwLSpk/img.png)

n개의 프로세스가 공유 데이터를 동시에 사용하기를 원하는 경우

각 프로세스의  code segment에는 공유 데이터를 접근하는 코드인 critical section이 존재합니다.

공유 데이터에 접근하는 코드를 Critical-Section입니다.

Problem: 하나의 프로세스가 Critical-Section에 있을 때 다른 모든 프로세스는 critical section에 들어갈 수 없어야 한다.(사용 중이면 기다려야 한다)

## [프로세스 동기화 #2](https://core.ewha.ac.kr/publicview/C0101020140404151340260748?vmode=f)



# Semaphores

- Integer variable(변숫값이 자원의 개수)
- 아래의 두 가지 atomic 연산에 의해서 접근 가능



![img](https://blog.kakaocdn.net/dn/7X5Ta/btreOttYaqU/xaXJg4ufDwMRNFEgNKwvGK/img.png)



P->공유 데이터를 획득하는 과정

V->공유 데이터를 다 사용하고 반납하는 과정.

## Critical Section of n Processes



![img](https://blog.kakaocdn.net/dn/LWsmL/btreJRC65Yn/uHKKcQFjsODO192kXkjAl0/img.png)



- 추상 자료 형태로 제공해주고 세마포어로 정의

## Block / Wakeup Implementation



![img](https://blog.kakaocdn.net/dn/ld6zh/btreLLaQdj3/KAWNC6HSTWKVtbIdxZzp31/img.png)



1. 세마포어를 획득할 수없다면 block를 시키고

2. 누군가가 세마포어를 쓰고 반납을 하면 깨워서 사용한다.



![img](https://blog.kakaocdn.net/dn/bbfgO8/btreJQKZWng/hG8SZDtuVfmri9qoS9gx21/img.png)



여기서 S.value는 상황을 나타냅니다.

음수-> 누군가가 자원을 기다리고 있다.

양수-> 자원이 여분이 있기 때문에 기다리지 않고 쓰고 있다.

# Two Types of Semaphores

- Counting semaphore
  - 도메인이 0 이상인 임의의 정수 값
- Binary semaphore(boolean?)
  - 0 또는 1 값만 가질 수 있는 semaphore
  - 주로 lock/unlock에 사용

# Deadlock and Starvation

Deadlock:둘 이상의 프로세스가 서로 상대방의 의해 충족될 수 있는 event를 무한히 기다리는 현상



![img](https://blog.kakaocdn.net/dn/M9E4N/btreKKwM3Gk/ly6yearYmmDcOFHfc0NuqK/img.png)



P0은 P(S)를 가지고 P1은 P(Q)를 가진 이후 P0은 P(Q)를 가져야 하고 P1은 P(S)를 가져야 하는데 서로 자원을 가진 이후 놓지 않고 계속 기다리는 상황.(상대방이 가진 것을 놓지 않고 서로 영원히 기다리는 상황)

## [프로세스 동기화 #3](https://core.ewha.ac.kr/publicview/C0101020140408134626290222?vmode=f)

## [프로세스 동기화 #4](https://core.ewha.ac.kr/publicview/C0101020140411143154161543?vmode=f)

### Classical Problems of Syncronization

- Bounded-Buffer Problem (Producer-Consumer Problem)
- Readers-Writers Problem
- Dining-Philosophers Problem

### Monitor

-
