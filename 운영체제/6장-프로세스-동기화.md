## [프로세스 동기화 #1](https://core.ewha.ac.kr/publicview/C0101020140401134252676046?vmode=f)
## 데이터의 접근

![img](https://blog.kakaocdn.net/dn/PB8tz/btreMvL5ZNN/7dbeFRKcJTdLJL0uHFXsZ0/img.png)

- 데이터를 읽어와서 연산된 데이터를 다시 위치한 데이터에 저장
- (1) CPU(연산) Memory(스토리지)
- (2) 컴퓨터내부(연산) 디스크(스토리지)
- (3) 프로세스(연산) 프로세스의 주소공간(스토리지)

## Race Condition

![img](https://blog.kakaocdn.net/dn/k1zF1/btrePVKvsnU/P7bFadmmZcTnzFsZNSKu11/img.png)

- 공통적인 데이터를 동시에 사용하려는 경우 한가지의 연산만 처리될 때 경쟁상태라고 말합니다.

### OS에서의 Race Condition

- 운영체제에서의 커널과 관련된 문제
- 프로세스는 일반적으로는 자기주소공간만 접근하기 때문에 Race Condition은 발생하지않는다.
- 프로세스들이 직접 실행할 수 없는 부분 운영체제에 요청하는 부분은 시스템 콜을 통해 실행합니다.
- 커널의코드가 그프로세스대신 실행(커널의 데이터를 접근), 이러한 상황에서 CPU를 뺏겨서 또다른 프로세스가 시스템콜을 한다면 Race Condition발생하게 된다.
- 운영체제의 커널 데이터가 공유데이터라 문제가 발생합니다.

## 대표적 OS Race Condition

1.Kernel 수행중 인터럽트 발생 시

![img](https://blog.kakaocdn.net/dn/Q1WXa/btreOs9CS82/xC3kR10KywnqP0nVLvOsp0/img.png)

해결책은 위의사진의 경우 Count++를 먼저 실행 후 작업이 끝난 이후 인터럽트를 실행시켜줍니다.

2. Process가 system call을 하여 kernel mode로 수행 중인데 context switch가 일어나는 경우

![img](https://blog.kakaocdn.net/dn/bLLDbv/btrePXBxoen/ijK3dgLvKhcVRSSGkXhqzk/img.png)

해결책: 커널 모드에서 수행 중일 떄는 CPU를 선점하지않고 커널모드에서 사용자모드로 선점합니다.

3. Multiprocessor에서 shared memory내의 kernel data

![img](https://blog.kakaocdn.net/dn/bZLxqq/btreKJdueUM/JRExfbQtfOYFUXwxjuZJc0/img.png)

해결책은: 커널 내부에 있는 공유 데이터에 대한 lock / unlock을 하여 관리

​				한번에 하나의 CPU만 커널에 들어가게하는 방법

### Process Synchronization 

문제공유 데이터의 동시 접근은 데이터의 불일치 문제를 발생시킬 수 있습니다.

일관성 유지를 위해서는 협력 프로세스간의 실행 순서를 정리해주는 매커니즘이 필요.

- Example of a Race Condition
- The Critical-Section Problem(임계구역)

공유데이터에 접근하는 코드를 Critical-Section 입니다.

Problem: 하나의 프로세스가 Critical-Section에 있을 때 다른 모든 프로세스는 critical section에 들어갈 수 없어야 한다.(사용중이면 기다려야한다)

## [프로세스 동기화 #2](https://core.ewha.ac.kr/publicview/C0101020140404151340260748?vmode=f)

# Semaphores

- Integer variable(변수값이 자원의 갯수)
- 아래의 두 가지 atomic 연산에 의해서 접근가능

![img](https://blog.kakaocdn.net/dn/cvTo6u/btreLg3c27K/vtyCzENkaMn08x0mJGHUZ0/img.png)

P->공유데이터를 획득하는과정

V->공유데이터를 다 사용하고 반납하는 과정.

## Critical Section of n Processes

![img](https://blog.kakaocdn.net/dn/6EGuy/btreKmv123v/OokRHKjrIwNeOZIYPkUw8k/img.png)

- 추상 자료형태로 제공해주고 세마포어로 정의

## Block / Wakeup Implementation

![img](https://blog.kakaocdn.net/dn/bz3NW5/btreMDQ949j/8TskSCFSgn7hP7msIabA1k/img.png)

1.세마포어를 획득할 수없다면 block를 시키고

2.누군가가 세마포어를 쓰고 반납을하면 깨워서 사용한다.

![img](https://blog.kakaocdn.net/dn/sWnap/btreKmCRVOz/awgzkeJG7txUK9kxoYastk/img.png)

여기서S.value는 상황을 나타냅니다.

음수->누군가가 자원을 기다리고있다.

양수->자원이 여분이 있기때문에 기다리지않고 쓰고있다. 

# Two Types of Semaphores

- Counting semaphore
  - 도메인이 0이상인 임의의 정수값
- Binary semaphore(boolean?)
  - 0 또는 1값만 가질 수 있는 semaphore
  - 주로 lock/unlock에 사용

# Deadlock and Starvation

Deadlock:둘 이상의 프로세스가 서로 상대방의 의해 충족될 수 있는 event를 무한히 기다리는현상

![img](https://blog.kakaocdn.net/dn/IhPCk/btreKwEXRNG/Vet71ikPEZ09vjKTY7L7nK/img.png)

P0은P(S)를 가지고 P1은P(Q)를 가진 이후 P0은 P(Q)를 가져야하고 P1은 P(S)를 가져야 하는데 서로 자원을 가진 이후 놓지 않고 계속 기다리는 상황.(상대방이 가진것을 놓지 않고 서로 영원히 기다리는 상황)

## [프로세스 동기화 #3](https://core.ewha.ac.kr/publicview/C0101020140408134626290222?vmode=f)

## [프로세스 동기화 #4](https://core.ewha.ac.kr/publicview/C0101020140411143154161543?vmode=f)

### Classical Problems of Syncronization

- Bounded-Buffer Problem (Producer-Consumer Problem)
- Readers-Writers Problem
- Dining-Philosophers Problem

### Monitor

-
