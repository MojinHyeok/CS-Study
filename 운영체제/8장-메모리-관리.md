## [메모리 관리 #1](https://core.ewha.ac.kr/publicview/C0101020140425151219100144?vmode=f)

# 메모리관리

논리적 주소

- 프로세스마다 독립적으로 가지는 주소공간
- 각 프로세스 마다 0 번지부터 시작
- CPU가 보는 주소는 logical address임

물리적 주소

- 메모리에 실제 올라가는 위치

주소바인딩 : 주소를 결정하는 것

Symbolic Address->logicial Address-> Physical address

Symbolic Address:프로그래머입장에서의 주소(숫자가아닌 상징성있는 주소를 사용한다)

![img](https://blog.kakaocdn.net/dn/bkC6zV/btrh0C83KDI/kqflxl1tXCtKU7fdwJWkV0/img.png)

![img](https://blog.kakaocdn.net/dn/bdiPcR/btrhUXfMaMm/YUuIS3EZfMwrclSVAgslS0/img.png)





# MMU

![img](https://blog.kakaocdn.net/dn/F1nGu/btrhZmk7dp4/aUZiW5iO6qF3KE2TrUkLI1/img.png)

CPU가 메모리 346번지 내용을 달라고하면 주소변환이 필요한데 주소변환을 해주는 것이 MMU 를 통해한다(relocation, limit regisgister를 통해)

relocation에 시작 위치를 저장 하고 

limit register는 악의적인 의도(남의 프로그램을 보려는)를 가지고 다른프로그램을 실행하려고하는것을 방지.



# Dynamic Loading

동적으로 올린다.(Loading:메모리롤 올리는 것)

- 프로세스 전체를 메모리에 미리 다 올리는 것이 아니라 해당 루틴이 불려질 때 메모리에 load하는 것
- 가끔씩 사용되는 많은 양의 코드의 경우 유용
- 운영체제의 특별한 지원 없이 프로그램 자체에서 구현 가능

OS라이브러리를 통해 지원 가능합니다.

# Overlay(다이나믹 과구분하여 야함)

- 메모리에 프로세스의 부분 중 실제 필요한 정보만을 올림

프로그래머가 수작업으로 처리 운영체제의 지원이 없음



# Swapping

- Swapping : 프로세스를 일시적으로 메모리에서 backing store로 쫓아내는 것
- Backing store(swap area) : 디스크, 많은 사용자의 프로세스 이미지를 담을 만큼 충분히 빠르고 큰 저장 공간
- Swap in/ Swap out
  - 일반적으로 중기 스케줄러에 의해 swap out 시킬 프로세스 선정
  - priority-based CPU scheduling algorithm: 우선순위 낮은 프로세스 swap out, 높은 프로세스 swap in
  - Compile time 혹은 load time binding에서는 원래 메모리 위치로 swap in 해야함
  - Run time binding에서는 빈 메모리 영역 아무 곳에나 올릴 수 있음
  - swap time은 대부분 transfer time(swap되는 양에 비례하는 시간)임



# Dynamic Linking

- Linking: 컴파일된 파일들을 하나로 묶는 작업 (ex. 라이브러리)
- Linking을 실행시간까지 미루는 기법
- Static Linking
  - 라이브러리가 프로그램의 실행 파일 코드에 포함됨
  - 실행 파일의 크기가 커짐
  - 동일한 라이브러리를 각각의 프로세스가 메모리에 올리므로 메모리 낭비
- Dynamic Linking
  - 라이브러리가 실행시 연결됨
  - 라이브러리 호출 부분에 라이브러리 루틴의 위치를 찾기 위한 stub라는 작은 코드를 둠
  - 라이브러리가 이미 메모리에 있으면 그 루틴의 주소로 가고 없으면 디스크에서 읽어옴
  - 운영체제의 도움이 필요



# Allocation of Physical Memory

- 메모리는 일반적으로 두 영역으로 나뉘어 사용
  - OS 상주 영역 
    - interrupt vector와 함께 낮은 주소 영역 사용
  - 사용자 프로세스 영역
    - 높은 주소 영역 사용
- 사용자 프로세스 영역의 할당 방법
  - Contiguous allocation(연속 할당)
    - 각각의 프로세스가 메모리의 연속적인 공간에 적재되도록 하는 것
      -  Fixed partition allocation
        - 융퉁성이 없음
      - Variable partition allocation
        - 외부조각의 발생
  - NonContiguous allocation
    - 하나의 프로세스가 메모리의 여러 영역에 분산되어 올라갈 수 있음
      - Paging
      - Segmentation
      - Paged Segmetation

# 연속할당

![img](https://blog.kakaocdn.net/dn/nnUKa/btrhUWm3ruW/1YGwNfXUlknVty5DszkdI0/img.png)

연속할당도 두가지 방식으로 분리가 됩니다.

프로그램이 들어갈 사용자 메모리 영역을 미리 파티션으로 나누어 놓는 개념입니다.

가변분할은 고정분할과 반대입니다.



고정분할에서의  외부조각과 내부조각

외부조각:프로그램을 올리려는데 올리려는 프로그램보다 크기가 작은 조각

내부조각:프로그램B를 올려 놨지만 사용하고도 남은 조각입니다.



가변분할방식

위의 사진에서 프로그램B를 사용하고 끝나고 남는 조각자리

![img](https://blog.kakaocdn.net/dn/bUyxMN/btrhVsNnIMF/jWA3KXAbDglNeIgKZVheJ1/img.png)

Dynamic Storage Allocation Problem

- 가변 분할 방식에서 size n인 요청을 만족하는 가장 적절한 hole을 찾는 문제

![img](https://blog.kakaocdn.net/dn/zEpd2/btrhX2HcpZm/m2OPlqjrDT8ElmwKE24sD0/img.png)

당연히 worst-fit이 제일 안좋다.

# 불연속할당

실제로 불연속할당을 주로 사용한다.

크게 페이징과 세그멘테이션기법으로 나눕니다.

페이징: 페이지를 같은 크기로 짜르는것(Hole이런 문제는 발생 하진 않음)

세그멘테이션기법: 의미있는 단위로 짜르는 것(크기가 균일하진 않음)




# 메모리 관리 

페이징 기법

![img](https://blog.kakaocdn.net/dn/xqmfT/btrj4sRlGL9/SAW38uuaVd9jjkfHHoRBv1/img.png)

page table(주소변환에 사용)

- 배열의 형태를 가지면서  논리적 메모리는 물리적 메모리 어디에 있는지에 관한 정보.
- 논리적 메모리의 수만큼 주소를 할당한다.
- 사용하는가 사용하지 않는가는 Valid(v), Invalid(i)를 통해 확인 가능.

### Implementation Of Page Table

- Page Table은 main memory에 상주
- Page-table base register (PTBR)가 page table을 가리킴
-  Page-table length register(PTLR)가 테이블 크기를 보관
- 모든 메모리 접근연산에는 2번의 메모리 접근이 필요
- page table접근 1번(주소변환), 실제 data/instruction 접근 1번(실제 데이터)

속도향상을 위하여TLB라는 캐시 메모리를 사용

![img](https://blog.kakaocdn.net/dn/bSclMg/btrj6cgGZza/nsMIp5mokZvvSHMErTseuk/img.png)

### 주소 변환을 위한 별도의 캐시 TLB

- 메모리 상에 접근하기전 TLB에 저장되어 있는 정보를 통해 주소 변환이 가능한지 먼저 참조
- TLB를 통해서는 메모리 접근 1번 이면 된다.
- TLB는 page table 전체를 가지는 것이 아니라 빈번하게 참조되는 일부를 가지고 있음
- 논리적 페이지 와 물리적 페이지의 쌍을 가지고 있어야함
- 특정항목만 아니라 전체를 검색해야합니다.-> 그리하여 병렬 검색을  가능하게 구현
- 프로세스마다 주소변환 정보가 다르기 때문에 매번 초기화를 진행해줘야함.



# 2단계 페이지 테이블

![img](https://blog.kakaocdn.net/dn/bndaZL/btrj4mYp10K/HItiACTF2cJkenGTZyt3jk/img.png)

왜사용하는가?(공간때문에)->공간이 너무 비효율 적이다.

궁극 적인 이유는  outer-page table은 그대로 만들지만 inner page table을 만들 떄에 사용하지 않는 값은 null값을 만듬으로 인해 효율적이다.

많은 부분을 사용하지 않기 때문에 이런 구조가 효율적입니다.



# 다단계 페이징 기법(Multilevel paging)

- TLB를 통해 메모리 접근 시간을 줄일 수 있음
- TLB를 통하지 않는다면 상당히 비효율 적이지만 TLB를 활용한다면 효율적입니다.
- 4단계 페이지 테이블을 사용하는 경우
  - 메모리 접근 시간이 100ns, TLB접근 식나이 20ns이고
  - TLB hit ration가 98%인 경우
    - effective memory access time= 0.98x120+0.02x 520=128nanoseconds
    - 28ns만 소요 이렇다면 크게 오버헤드가 발생하지 않는다.



### Inverted Page Table

![img](https://blog.kakaocdn.net/dn/EF1ql/btrj3NhGmm3/u4t37yZqIY0tbd99xv8731/img.png)

- page table의 가장 큰 문제는 너무 큰 공간을 가지고있는다.
- 물리적주소를 통해 논리적 주소를 알아내는 방법?(논리적메모리의 개수만큼이아니라 물리적메모리 개수만큼 존재)
- 일일이 전부 확인해야한다.
- 이러한 Page Table의 궁긍적인 목적은 공간을 줄이고자가 목적.
- 시간적 오버헤드가 큼. (극복하기 위해 병렬적 탐색을 가능하게 구현)



# Segmentation

프로그램을 의미 단위로 나누는 것

- 프로그램은 의미 단위인 여러 개의 segment로 구성
  -  작게는 프로그램을 구성하는 함수 하나하나를 세그먼트로 정의
  -  크게는 프로그램 전체를 하나의 세그먼트로 정의 가능
- Segment-table base register(STBR)
  - 물리적 메모리에서의 segment table의 위치
- Segment-table length register(STLR)
  - 프로그램이 사용하는 segment의 수 

Logical address 는 < segment-number, offset> 으로 구성

![img](https://blog.kakaocdn.net/dn/bcV4oW/btrj3NosQNY/WOjmS2K18Le7KNgd20RBuk/img.png)

CPU가 논리주소를 준다면 논리번호와 주소로 나눕니다.

limit(세그먼트의 길이)은 세그먼트는 길이가 다 다르기 떄문에 limit도 나타내야합니다.

의미단위로 자르기 떄문에 길이가 다를 수 있다.

##### 체크사항2가지

- 세그먼트 번호가 STLR보다 크다면 트랩에 걸리게 된다.

- 주소 변환을 하는데 limit보다 offset이 크다면 트랩에 걸리게 되다.



segment는 의미 단위이기 때문에 공유와 보안에 있어 paging보다 훨씬 효과적이다.

단점은 동일한 크기가 아니기 때문에 holl과 빈공간이 나타날 수 있다.

## 세그먼트의 예시

![img](https://blog.kakaocdn.net/dn/kRKsO/btrkekq3NOm/g2ENuKZAwIMavLDvjyza31/img.png)

Shared Segment(같은 논리적인 주소상에 있어야한다 세그먼트 번호가 같아야함)

![img](https://blog.kakaocdn.net/dn/cOJaNS/btrj4XD8gpu/tUHs4ZkTwk0zoIzBC9D7Wk/img.png)

editor는 공유하고 data1,2는 프라이빗으로 개인적으로 처리한 그림.

## Paged Segmentation

올라갈 때는 페이지 단위로 올라가고, table은 segment로 관리

holl과 같은 공간 소비는 없어짐

